#!/opt/local/bin/gnuplot -persist
#
#    
#    	G N U P L O T
#    	Version 4.6 patchlevel 6    last modified September 2014
#    	Build System: Darwin i386
# -------------------------------------------------------------------------------------


# -------------------------------------------------------------------------------------
# USE THIS SCRIPT TO PLOT RANDOM FIELDS GENERATED BY fractals AND STORED AS BINARY DATA
# Note that a 1D data "cube" consists generally of N complex numbers, and thus stores 2*N
# real values (one for the real, one for the imaginary part). A 2D or 3D data cube of size
# N1*N2*N3 stores N1*N2*N3 complex values or N1*N2*(2*N3) real values. In either case, the
# real and imaginary part of a given complex number are contiguous in memory. Note also that
# N3 is the dimension of the "fastest" (or contiguos in memory) index, followed by N2, etc.



# IMPORTANT: Apparently gnuplot cannot handle binary data in 3D, i.e., a 3D field, where each
# entry in the file represents the field value at a 3D-point. This works fine in 1D and 2D.
# For example, using the directive array=(X,Y), gnuplot interpretes the input binary data as a
# sequence of XxY Z values, and plots the Z value at a point (j,i) automatically generated,
# assuming i to be the "slowest" index. Ideally, using the directive array=(X,Y,Z) or array=XxYxZ
# should tell gnuplot to interprete a 3D data cube as having dimensions X, Y, and Z, and plotting
# the field value f(k,j,i) at a point automatically generated. But this does not work...So, here
# is the workaround: the TRICK is to consider the data cube as if it consisted of a single data
# set of length 2*N3 | N2*(2*N3) | N1*N2*(2*N3) (depending on the dimension) and to define a function
# to generate to coordinates from the index as given by column(0) or $0.

# define coordinates function; not actually necessary for 1D and 2D data (see below). Note the
# explicit conversion from int to float; this is necessary otherwise the indices are wrong.

coord(x, s1, s2) = (ceil((1+int(x))/(1.*s1)) % s2 > 0 ? ceil((1+int(x))/(1.*s1)) % s2 : s2)

# ALTERNATIVE: is to store the indices (k,j,i) in the data cube, such that each record consists
# of a 4-tuple (k,j,i, field). In this case, the plotting directive is basically, for 3D:
#
# gnuplot> pl 'file' binary record=(2*N3)*N2*N1 u 1:2:3:4 w p lc variable
#
# But it does seem like a waste of memory to do so. Therefore, I prefere the first approach.

# -------------------------------------------------------------------------------------
# EDIT HERE

# Terminal type (choose one; x11 is default). If pngcairo is chosen, an output file name  with
# the same name as the input file name and extension .png will be produced and opened.

# termType = "x11"
termType = "PNGC"

# Define the dimensionality of the problem (choose only one!)

# numDims = 1
numDims = 2
# numDims = 3
# numDims = 4 // not yet finished!

# linear dimension of cube
# DIM = 8192
# DIM = 2048
# DIM = 1024
DIM = 512
# DIM = 256
# DIM = 128

# Define the number format (choose only one!)

# numFormat = "%float"
numFormat = "%double"

# Define the file name bits (choose only one of each)

# fileInfix = "ini"
fileInfix = "filt"

# filePrefix = "gauss"
filePrefix = "lognorm"

# Define the last iteration (only when debugging)
# iterLast = 15
iterLast = ''

# Define the minimum wavelength in data (this will affect the linear
# fit to the power spectrum)
KMIN = 1
# Define the minimum wavelength in plot (this will affect only the plot range)
KMINPLOT = 1

# Use FULL or REALONLY data file?
# NOTE: This DOES not refer to which part of the field should be used, but rather which
# output file is read. There should be no difference between them (as long as the real part
# of the field is read from the full data file) and this is only used as a consistency
# check to make sure that the real data-only file is correct.
dataFile = "FULL"
# dataFile = "REALONLY"

# Plot real or imaginary part of field? NOTE: requires dataFile = "FULL"
dataType = "REAL"
# dataType = "IMA"

# -------------------------------------------------------------------------------------
# DO NOT EDIT BELOW THIS LINE
# ---------------------------------------------------------------------------------------

# set appropriate plotting scale
if (filePrefix eq "gauss") {
	scaleFunc(x) = (x)
	dataFunc(x) = (x)
} else {
	scaleFunc(x) = log10(x)
	dataFunc(x) = log(x)
}


# Use FULL field data or REAL?
if(dataFile eq "FULL"){

	fileNameBDat = filePrefix.sprintf("%dd_", numDims).fileInfix.".bdat"

	dimFact = 2

	if(dataType eq "REAL"){
		ptStart = 0
	}
	if(dataType eq "IMA"){
		ptStart = 1
	}

	ptIncr = 2


}

if(dataFile eq "REALONLY"){

	if(fileInfix eq "ini"){
		print "\n\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
		print "WARNING: REALONLY data file for inital Gaussian field may not exist."
		print "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n"
	}

	if(dataType eq "IMA"){
		print "\n\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
		print "\n\nERROR: Cannot plot IMAGINARY part from REALONLY data file! Abort.\n\n"
		print "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n"
		quit
	}

	fileNameBDat = filePrefix.sprintf("%dd_", numDims).fileInfix."_Real.bdat"

	dimFact = 1
	ptStart = 0
	ptIncr = 1

}

# set coordinate step
DX = 1.0/dimFact
DY = 1.

# set input file name

fileLegend = filePrefix.sprintf("%dd-", numDims).fileInfix.".bdat"
# fileNameASCIIDat = filePrefix.sprintf("%dd_", numDims).fileInfix.".dat"

# set output file name
if (termType eq "PNGC") {
	outFileNameSpec = filePrefix.sprintf("%dd_", numDims).fileInfix."_powSpec.png"
	outFileNameField = filePrefix.sprintf("%dd_", numDims).fileInfix.".png"
	outFileNameHisto = filePrefix.sprintf("%dd_", numDims).fileInfix."_histo.png"
}

# set size of numbers in bytes
if (numFormat eq "%float") {
	numSize = 4
}
if (numFormat eq "%double") {
	numSize = 8
}

# define data "cube" ACTUAL dimensions, i.e. the number of REAL values stored.
# Note that DIM3 is the dimension of the "fastest" (or contiguos in memory) index,
# followed by DIM2, etc.


# use this when reading FULL field:
# factor dimFact = 1, 2 depending on whether we are dealing with a data file
# storing N complex numbers (equivalent to 2N real numbers; FULL) or N real numbers (REALONLY)
# Note: this needs to be adjust to allow for visualising the imaginary part of the field as
# well when using the FULL data file!
DIM3 = dimFact * DIM
DIM2 = DIM
DIM1 = DIM

# ---------------------------------------------------------------------------------------

# fit options
set fit quiet

# use this to place key in front
set key opaque nobox Right

# thicker border
set border lw 2


# Plot in 1D
if (numDims == 1) {

	# set square canvas
	if (termType eq "PNGC") {
		set term pngc enhanced color dashed size 594, 594
	}

	# set square graph
	set size ratio 1

	# Plot power spectrum

	if (termType eq "PNGC") {
		set output outFileNameSpec
		lcolor = "black"
	} else {
		set term x11 0 dashed persist size 594, 594
		lcolor = "black"
	}

	# Fit line to P(k)
	set autoscale
	g(x) = a*x + b
	fit [ log10(KMIN) : * ] [ * : * ] g(x) \
	"powSpec".sprintf("%dd_", numDims)."lognorm".iterLast.".bdat" binary record=(1.*DIM/2.) format=numFormat \
	u (log10($0)):(log10($1)) via a,b

	set xrange [ log10(KMINPLOT) : (log10(DIM)) ]
	set yrange [ * : * ]
	set xlabel "log_{10}[ wavenumber (k) ]"
	set ylabel "log_{10}[ Power ]"

	pl \
	"powSpec".sprintf("%dd_", numDims)."gauss".iterLast.".bdat" binary record=(1.*DIM/2.) \
	format=numFormat u (log10($0)):(log10($1)) w l dt 2 lw 2 lc rgb lcolor t "Gaussian seed", \
	"powSpec".sprintf("%dd_", numDims)."lognorm".iterLast.".bdat" binary record=(1.*DIM/2.) \
	format=numFormat u (log10($0)):(log10($1)) w l lt 3 lw 2 lc rgb lcolor t "Log-normal final", \
	g(x) w l lt 1 lw 1 lc rgb "red" t sprintf("{/Symbol b}=%5.3f", a)

	# close stream and open output file
	if (termType eq "PNGC") {
		unset output
		system "open ".outFileNameSpec." &"
	}

	# delete fit log file
	system " rm -f fit.log"


	# Plot random field density

	set autoscale

	# data statistics (linear scale)
	stats fileNameBDat binary record=(DIM3) format=numFormat every ptIncr::ptStart u (dataFunc($1))

	# Gaussian parameters
	m = STATS_mean
	s = STATS_stddev

	# log-normal parameters
	mu = exp(m + 0.5 * s*s)
	sigma = mu * sqrt(exp(s*s) - 1)

	# data statistics (appropriate scale for the field)
	stats fileNameBDat binary record=(DIM3) format=numFormat every ptIncr::ptStart u (scaleFunc($1)) nooutput


	if (termType eq "PNGC") {
		set output outFileNameField
	} else {
		set term x11 1 persist size 594, 594
	}

	set xrange [ 0 : DIM ]
	set yrange [ * : * ]
	set xlabel "x"

	# set colour range
	if (filePrefix eq "gauss") {

		set ytics format "%4.1f"
		set ylabel "| density |"

		set label sprintf("m = %7.2f", m) tc rgb "black" front at screen 0.65, 0.8
		set label sprintf("s = %7.2f", s) tc rgb "black" front at screen 0.65, 0.75

	} else {


		set ytics format "%3.1f"
		set ylabel "log[ density ]"

		set label sprintf("{/Symbol m} = %7.2f", mu) tc rgb "black" front at screen 0.65, 0.8
		set label sprintf("{/Symbol s} = %7.2f", sigma) tc rgb "black" front at screen 0.65, 0.75
	}

	set title filePrefix # dataType

	pl fileNameBDat binary record=(DIM3) format=numFormat \
	every ptIncr::ptStart u ($0*DX):(scaleFunc($1)) w p not


	set table 'test.dat'
	replot
	unset table

	# close stream and open output file
	if (termType eq "PNGC") {
		unset output
		system "open ".outFileNameField." &"
	}

	# create histogram

	if (termType eq "PNGC") {
		set output outFileNameHisto
	} else {
		set term x11 2 persist size 594, 594
	}

	# Note: The shift in the binning function bin by 0.5 units is required to correctly estimate
	# the mean value when fitting (why?)
	binSize = 0.2
	bin(x,s) = s*(floor(x/s)+0.5)
	gauss(x) = exp(-0.5*(x-avg)*(x-avg)/sig/sig)/sqrt(2.*pi)/sig

	set xrange [ * : * ]
	set yrange [ * : * ]
	set ytics format "%e"

	# NOTE: the total number of values read is DIM3, but the total number of values
	# that go into the histogram is DIM3/ptIncr
	set table 'gaussfit.dat'
		pl fileNameBDat binary record=(DIM3) format=numFormat every ptIncr::ptStart \
		u (bin(dataFunc($1),binSize)):(1./(DIM3/ptIncr)/binSize) \
		smooth frequency
	unset table

	fit [ * : * ] [ * : * ] gauss(x) 'gaussfit.dat' u ($1):($2) via avg,sig

	stats 'gaussfit.dat' u 2 nooutput

	set xrange [ * : * ]
	set yrange [ * : 1.25*STATS_max ]
	set ytics format "%3.1f"
	set xlabel "log[density]"
	set ylabel "PDF"
	unset label
	set label sprintf("%3s = %7.2f", 'm', avg) tc rgb "black" front at screen 0.75, 0.85
	set label sprintf("%3s = %7.2f", 's', sig) tc rgb "black" front at screen 0.75, 0.80
	set key top left Left reverse spacing 1.5 height 1.
	pl 'gaussfit.dat' u ($1):($2) w p ps 2 lw 2 t "Data", \
	'+' u ($1):(gauss($1)) w l lw 2 t "Gaussian fit"

	# close stream and open output file
	if (termType eq "PNGC") {
		unset output
		system "open ".outFileNameHisto." &"
	}

	# remove auxiliary file
# 	system "rm -f gaussfit.dat"

	quit

} # 1D


# Plot in 2D
if (numDims == 2) {

	# set square canvas
	if (termType eq "PNGC") {
		set term pngc enhanced color dashed size 594, 594
	}

	# set square graph
	set size ratio 1

	# Plot power spectrum

	if (termType eq "PNGC") {
		set output outFileNameSpec
		lcolor = "black"
	} else {
		set term x11 0 dashed persist size 594, 594
		lcolor = "black"
	}

	# Fit line to P(k)
	set autoscale
	g(x) = a*x + b
	fit [ log10(KMIN) : * ] [ * : * ] g(x) \
	"powSpec".sprintf("%dd_", numDims)."lognorm".iterLast.".bdat" binary record=(1.*DIM/2.) format=numFormat \
	u (log10($0)):(log10($1)) via a,b

	set xrange [ log10(KMINPLOT) : (log10(DIM)) ]
	set yrange [ * : * ]
	set xlabel "log_{10}[ wavenumber (k) ]"
	set ylabel "log_{10}[ Power ]"
	set key top right spacing 1.5 height 1.

	pl \
	"powSpec".sprintf("%dd_", numDims)."gauss".iterLast.".bdat" binary record=(1.*DIM/2.) format=numFormat \
	u (log10($0)):(log10($1)) w l dt 2 lw 2 lc rgb lcolor t "Gaussian seed", \
	"powSpec".sprintf("%dd_", numDims)."lognorm".iterLast.".bdat" binary record=(1.*DIM/2.) format=numFormat \
	u (log10($0)):(log10($1)) w l lt 3 lw 2 lc rgb lcolor t "Log-normal final", \
	g(x) w l lt 1 lw 1 lc rgb "red" t sprintf("{/Symbol b}=%5.3f", a)

	# close stream and open output file
	if (termType eq "PNGC") {
		unset output
		system "open ".outFileNameSpec." &"
	}

	# delete fit log file
	system " rm -f fit.log"


	# Plot random field density

	set autoscale

	# data statistics (linear scale)
	stats fileNameBDat binary record=(DIM3*DIM2) format=numFormat every ptIncr::ptStart u (dataFunc($1))

	# Gaussian parameters
	m = STATS_mean
	s = STATS_stddev

	# log-normal parameters
	mu = exp(m + 0.5 * s*s)
	sigma = mu * sqrt(exp(s*s) - 1)

	# data statistics (appropriate scale for the field)
	stats fileNameBDat binary record=(DIM3*DIM2) format=numFormat every ptIncr::ptStart u (scaleFunc($1)) nooutput


	if (termType eq "PNGC") {
		set output outFileNameField
	} else {
		set term x11 1 persist size 594, 594
	}

	set xrange [ 0 : DIM ]
	set yrange [ 0 : DIM ]
	set xlabel "x"
	set ylabel "y"
	unset key

	# set colour range
	if (filePrefix eq "gauss") {

		set cbrange [ floor(STATS_min) : ceil(STATS_max) ]
		set cbtics format "%4.1f"
		set cblabel "| density |" offset 0.5, 1 rotate by -90

		unset label
		set label sprintf("m = %7.2f", m) tc rgb "white" front at screen 0.65, 0.8
		set label sprintf("s = %7.2f", s) tc rgb "white" front at screen 0.65, 0.75

	} else {


		set cbrange [ floor(0.1 * STATS_max) : ceil(0.5 * STATS_max) ]
		set cbtics format "%3.1f"
		set cblabel "log_{10}[ density ]" offset 0.5, 1 rotate by -90

		unset label
		set label sprintf("{/Symbol m} = %7.2f", mu) tc rgb "white" front at screen 0.65, 0.8
		set label sprintf("{/Symbol s} = %7.2f", sigma) tc rgb "white" front at screen 0.65, 0.75
	}

	set title filePrefix # dataType

	pl fileNameBDat binary array=(DIM3,DIM2) format=numFormat scan=xy \
	dx=DX dy=DY origin=(0.,0.5*DY) every ptIncr::ptStart u (scaleFunc($1)) w ima not


	# close stream and open output file
	if (termType eq "PNGC") {
		unset output
		system "open ".outFileNameField." &"
	}


	# create histogram

	if (termType eq "PNGC") {
		set output outFileNameHisto
	} else {
		set term x11 2 persist size 594, 594
	}

	# Note: The shift in the binning function bin by 0.5 units is required to correctly estimate
	# the mean value when fitting (why?)
	binSize = 0.1
	bin(x,s) = s*(floor(x/s)+0.5)
	gauss(x) = exp(-0.5*(x-avg)*(x-avg)/sig/sig)/sqrt(2.*pi)/sig

	set xrange [ * : * ]
	set yrange [ * : * ]

	# NOTE: the total number of values read is DIM3*DIM2, but the total number of values
	# that go into the histogram is DIM3*DIM2/ptIncr
	set table 'gaussfit.dat'
		pl fileNameBDat binary record=(DIM3*DIM2) format=numFormat every ptIncr::ptStart \
		u (bin(dataFunc($1),binSize)):(1./(DIM3*DIM2/ptIncr)/binSize) \
		smooth frequency
	unset table

	fit [ * : * ] [ * : * ] gauss(x) 'gaussfit.dat' u ($1):($2) via avg,sig

	stats 'gaussfit.dat' u 2 nooutput

	set xrange [ * : * ]
	set yrange [ * : 1.25*STATS_max ]
	set xlabel "log[density]"
	set ylabel "PDF"
	unset label
	set label sprintf("%3s = %7.2f", 'm', avg) tc rgb "black" front at screen 0.75, 0.85
	set label sprintf("%3s = %7.2f", 's', sig) tc rgb "black" front at screen 0.75, 0.80
	set key top left Left reverse spacing 1.5 height 1.
	pl 'gaussfit.dat' u ($1):($2) w p ps 2 lw 2 t "Data", \
	'+' u ($1):(gauss($1)) w l lw 2 t "Gaussian fit"

	# close stream and open output file
	if (termType eq "PNGC") {
		unset output
		system "open ".outFileNameHisto." &"
	}

	# remove auxiliary file
	system "rm -f gaussfit.dat"

	quit

} # 2D


# Plot in 3D: This is a fly-thru the volume slice by slice

# set square canvas
if (termType eq "PNGC") {
	set term pngc enhanced color dashed size 594, 594
}

# set square graph
set size ratio 1

if (numDims == 3) {

	# Plot power spectrum

	if (termType eq "PNGC") {
		set output outFileNameSpec
		lcolor = "black"
	} else {
		set term x11 0 dashed persist size 594, 594
		lcolor = "black"
	}

	# Fit line to P(k)
	set autoscale
	g(x) = a*x + b
	fit [ log10(KMIN) : * ] [ * : * ] g(x) "powSpec".sprintf("%dd_", numDims)."lognorm".iterLast.".bdat" \
	binary record=(1.*DIM/2.) format=numFormat u (log10($0)):(log10($1)) via a,b


	set xrange [ log10(KMINPLOT) : (log10(DIM)) ]
	set yrange [ * : * ]
	set xlabel "log_{10}[ wavenumber (k) ]"
	set ylabel "log_{10}[ Power ]"

	pl "powSpec".sprintf("%dd_", numDims)."gauss".iterLast.".bdat" binary record=(1.*DIM/2.) format=numFormat \
	u (log10($0)):(log10($1)) w l dt 2 lw 2 lc rgb lcolor t "Gaussian seed", \
	"powSpec".sprintf("%dd_", numDims)."lognorm".iterLast.".bdat" binary record=(1.*DIM/2.) format=numFormat \
	u (log10($0)):(log10($1)) w l lt 3 lw 2 lc rgb lcolor t "Log-normal final", \
	g(x) w l lt 1 lw 1 lc rgb "red" t sprintf("{/Symbol b}=%5.3f", a)

	# close stream and open output file
	if (termType eq "PNGC") {
		unset output
		system "open ".outFileNameSpec." &"
	}

	# delete fit log file
	system " rm -f fit.log"


	# Plot random field density

	set macros

	# data statistics (in linear scale)
	stats fileNameBDat binary record=(DIM3*DIM2*DIM1) format=numFormat every ptIncr::ptStart u (dataFunc($1))

	# Gaussian parameters
	m = STATS_mean
	s = STATS_stddev

	# log-normal parameters
	mu = exp(m + 0.5 * s*s)
	sigma = mu * sqrt(exp(s*s) - 1)


	# data statistics (appropriate scale for the field)
	stats fileNameBDat binary record=(DIM3*DIM2*DIM1) format=numFormat every ptIncr::ptStart u (scaleFunc($1)) nooutput

	if (termType eq "x11") {
		set term x11 1 persist
	}

	set xrange [ 0 : DIM ]
	set yrange [ 0 : DIM ]

	set xlabel "x"
	set ylabel "y"

	set size ratio 1.

	# set colour range
	if ((filePrefix eq "gauss") && (fileInfix eq "ini") ){
		set cbrange [ STATS_min : STATS_max ]
		set cbtics format "%3.1f"
		set cblabel "linear density" offset 0.5, 1 rotate by -90
		set label sprintf("m = %7.2f", m) tc rgb "white" front at screen 0.65, 0.8
		set label sprintf("s = %7.2f", s) tc rgb "white" front at screen 0.65, 0.75
	}
	else {
		set cbrange [ floor(0.1 * STATS_max) : ceil(0.9 * STATS_max) ]
		set cbtics format "%3.1f"
		set cblabel "log_{10}[ density ]" offset 0.5, 1 rotate by -90
		set label sprintf("{/Symbol m} = %7.2f", mu) tc rgb "white" front at screen 0.65, 0.8
		set label sprintf("{/Symbol s} = %7.2f", sigma) tc rgb "white" front at screen 0.65, 0.75
	}

	set title filePrefix # dataType

	set key bottom right

if (termType eq "PNGC") {

	do for [i=0:DIM1-1] { \

		# set output file name
		outFileNameField = filePrefix.sprintf("%dd_%03d_", numDims, i).fileInfix.".png"

		set output outFileNameField

		slice_str = sprintf("\"Creating plot for slice = %4d\"", i)
		system "printf %s ".slice_str."\r "

		pl fileNameBDat binary array=(DIM3,DIM2) format=numFormat \
		skip=(numSize*(DIM3*DIM2)*i) dx=DX dy=DY origin=(0.,0.5*DY) \
		every ptIncr::ptStart u (scaleFunc($1)) with ima title sprintf("slice = %d", i)

		unset output

	}

	print "\n\nDone.\n"

	# open output files
	system "open ".filePrefix.sprintf("%dd_*", numDims).fileInfix.".png &"

} else {

	# the factor 4 in skip is to account for 4 bytes (float)
	do for [i=0:DIM1-1] { \
		pl fileNameBDat binary array=(DIM3,DIM2) format=numFormat \
		skip=(numSize*(DIM3*DIM2)*i) dx=DX dy=DY origin=(0.,0.5*DY) \
		every ptIncr::ptStart u (scaleFunc($1)) with ima title sprintf("slice = %d", i); \
		pause 1
	}

}

	# create histogram

	if (termType eq "PNGC") {
		set output outFileNameHisto
	} else {
		set term x11 2 persist size 594, 594
	}

	# Note: The shift in the binning function bin by 0.5 units is required to correctly estimate
	# the mean value when fitting (why?)
	binSize = 0.5
	bin(x,s) = s*(floor(x/s)+0.5)
	gauss(x) = exp(-0.5*(x-avg)*(x-avg)/sig/sig)/sqrt(2.*pi)/sig

	set xrange [ * : * ]
	set yrange [ * : * ]

	# NOTE: the total number of values read is DIM3*DIM2*DIM1, but the total number of values
	# that go into the histogram is DIM3*DIM2*DIM1/ptIncr
	set table 'gaussfit.dat'
		pl fileNameBDat binary record=(DIM3*DIM2*DIM1) format=numFormat every ptIncr::ptStart \
		u (bin(dataFunc($1),binSize)):(1./(DIM3*DIM2*DIM1/ptIncr)/binSize) \
		smooth frequency
	unset table

	fit [ * : * ] [ * : * ] gauss(x) 'gaussfit.dat' u ($1):($2) via avg,sig

	stats 'gaussfit.dat' u 2 nooutput

	set xrange [ * : * ]
	set yrange [ * : 1.25*STATS_max ]
	set xlabel "log[density]"
	set ylabel "PDF"
	unset label
	set label sprintf("%3s = %7.2f", 'm', avg) tc rgb "black" front at screen 0.75, 0.85
	set label sprintf("%3s = %7.2f", 's', sig) tc rgb "black" front at screen 0.75, 0.80
	set key top left Left reverse spacing 1.5 height 1.
	pl 'gaussfit.dat' u ($1):($2) w p ps 2 lw 2 t "Data", \
	'+' u ($1):(gauss($1)) w l lw 2 t "Gaussian fit"

	# close stream and open output file
	if (termType eq "PNGC") {
		unset output
		system "open ".outFileNameHisto." &"
	}

	# remove auxiliary file
	system "rm -f gaussfit.dat"

	quit

} // 3D

# Plot in "4D", i.e field value at point (x,y,z) given by a symbol color | size | type
if (numDims == 4) { # NOT YET FINISHED!

	# data statistics (in linear scale)
	stats fileNameBDat binary record=(DIM3*DIM2*DIM1) format=numFormat every ptIncr::ptStart u (($1))

	set xlabel "x"
	set ylabel "y"
	set zlabel "z"


	# real part
	set term x11 0 persist
	set title "modulus(real)"
	spl fileNameBDat binary record=(DIM3*DIM2*DIM1) format=numFormat every ptIncr::ptStart \
	u (ceil(0.5*coord($0,1.,DIM3))):(coord($0,DIM3,DIM2)):(coord($0,(DIM3*DIM2),DIM1)):(sqrt($1*$1)) w p lc variable

	# imaginary part
# 	set term x11 1 persist
# 	set title "modulus(imaginary)"
# 	spl fileNameBDat binary record=(DIM3*DIM2*DIM1) format=numFormat every 2::1 \
u (ceil(0.5*coord($0,1.,DIM3))):(coord($0,DIM3,DIM2)):(coord($0,(DIM3*DIM2),DIM1)):(sqrt($1*$1)) w p lc variable

# 	#real part (to check that everything is 0K)
# 	set term x11 2 persist
# 	set title "modulus(real)"
# 	spl fileNameASCIIDat u 1:2:3:(sqrt($4*$4)) w p lc variable

	quit

} # 4D

# EOF